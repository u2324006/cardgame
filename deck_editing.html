<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>デッキ編集</title>
        <link rel="stylesheet" href="css/style.css">
    
</head>
<body>
    <div class="deck-editing-wrapper">
        <div class="left-column">
            <div id="card-info-panel" class="card-info-panel">
                <h2>カード情報</h2>
                <p>カードにカーソルを合わせると詳細が表示されます。</p>
            </div>
            <div class="action-buttons">
                <button id="save-deck-button" class="btn">デッキを保存</button>
                <button id="back-button" class="btn">戻る</button>
            </div>
        </div>

        <div class="right-column">
            <div class="current-deck-section">
                <h2>現在のデッキ (<span id="deck-count">0</span>/40)</h2>
                <div id="current-deck-grid" class="deck-grid">
                    <!-- Cards in the current deck will be loaded here by JavaScript -->
                </div>
            </div>

            <div class="card-list-section">
                <h2>カード一覧</h2>
                <div id="all-cards-grid" class="card-grid">
                    <!-- All available cards will be loaded here -->
                </div>
            </div>
        </div>
    </div>

    <script src="data/cards.js"></script>
    <script src="js/ui.js"></script>
    <script>
        const cardInfoPanel = document.getElementById('card-info-panel');
        const allCardsGrid = document.getElementById('all-cards-grid');
        const currentDeckGrid = document.getElementById('current-deck-grid');
        const saveDeckButton = document.getElementById('save-deck-button');
        const backButton = document.getElementById('back-button');
        const deckCountSpan = document.getElementById('deck-count');

        let currentDeck = [];
        let draggedCardId = null;
        let draggedFromDeck = false;

        function updateDeckCount() {
            if (deckCountSpan) {
                deckCountSpan.textContent = currentDeck.length;
            }
        }

        function renderCardItemHtml(cardData) {
            return `
                <div class="card-item" draggable="true" data-id="${cardData.id}">
                    <p>${cardData.name}</p>
                </div>
            `;
        }

        function attachCardEventListeners(cardItems) {
            cardItems.forEach(item => {
                item.addEventListener('mouseover', () => {
                    const cardId = item.dataset.id;
                    const cardData = allCardsData.find(c => c.id === cardId);
                    cardInfoPanel.innerHTML = renderCardDetails(cardData);
                });
                item.addEventListener('mouseout', () => {
                    cardInfoPanel.innerHTML = renderCardDetails(null);
                });
                item.addEventListener('dragstart', (e) => {
                    draggedCardId = item.dataset.id;
                    draggedFromDeck = item.closest('#current-deck-grid') !== null;
                    e.dataTransfer.setData('text/plain', draggedCardId);
                    e.dataTransfer.effectAllowed = 'move';
                });
            });
        }

        function customDeckSort(a, b) {
            const aIsMonster = a.type === 'Monster';
            const bIsMonster = b.type === 'Monster';
            if (aIsMonster && !bIsMonster) return -1;
            if (!aIsMonster && bIsMonster) return 1;
            const costA = parseInt(a.cost, 10);
            const costB = parseInt(b.cost, 10);
            if (costA > costB) return -1;
            if (costA < costB) return 1;
            return a.name.localeCompare(b.name);
        }

        function renderDeckGrid(gridElement, cards) {
            const cardsHtml = cards.map(card => renderCardItemHtml(card)).join('');
            gridElement.innerHTML = cardsHtml;
            attachCardEventListeners(gridElement.querySelectorAll('.card-item'));
            updateDeckCount();
        }

        function renderAllCardsGrid(gridElement, cards) {
            const cardsHtml = cards.map(card => renderCardItemHtml(card)).join('');
            gridElement.innerHTML = cardsHtml;
            attachCardEventListeners(gridElement.querySelectorAll('.card-item'));
        }

        function loadDeck() {
            const selectedDeckIndex = localStorage.getItem('selectedDeckIndex');
            if (selectedDeckIndex === null) {
                window.location.href = 'deck_selection.html';
                return;
            }
            const decks = JSON.parse(localStorage.getItem('decks')) || [[], [], []];
            currentDeck = decks[selectedDeckIndex] || [];
            renderDeckGrid(currentDeckGrid, currentDeck);
        }

        function validateDeck(deck) {
            if (deck.length !== 40) {
                return { isValid: false, message: `デッキの枚数は40枚である必要があります。現在 ${deck.length} 枚です。` };
            }
            const cardCounts = {};
            for (const card of deck) {
                cardCounts[card.id] = (cardCounts[card.id] || 0) + 1;
                if (cardCounts[card.id] > 3) {
                    const cardName = allCardsData.find(c => c.id === card.id).name;
                    return { isValid: false, message: `同じカードは3枚までです。'${cardName}' が4枚以上あります。` };
                }
            }
            return { isValid: true, message: 'デッキは有効です。' };
        }

        function saveDeck() {
            const selectedDeckIndex = localStorage.getItem('selectedDeckIndex');
            if (selectedDeckIndex === null) {
                alert("エラー: 保存するデッキが選択されていません。");
                return;
            }
            const decks = JSON.parse(localStorage.getItem('decks')) || [[], [], []];
            decks[selectedDeckIndex] = currentDeck;
            localStorage.setItem('decks', JSON.stringify(decks));
            alert('デッキを保存しました。');
            window.location.href = 'deck_selection.html';
        }

        [currentDeckGrid, allCardsGrid].forEach(grid => {
            grid.addEventListener('dragover', (e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; });
            grid.addEventListener('drop', (e) => {
                e.preventDefault();
                const cardId = e.dataTransfer.getData('text/plain');
                const fromDeck = draggedFromDeck;
                const toDeck = grid.id === 'current-deck-grid';
                if (fromDeck && !toDeck) {
                    const cardIndex = currentDeck.findIndex(card => card.id === cardId);
                    if (cardIndex > -1) {
                        currentDeck.splice(cardIndex, 1);
                    }
                } else if (!fromDeck && toDeck) {
                    const cardData = allCardsData.find(card => card.id === cardId);
                    if (cardData) {
                        currentDeck.push(cardData);
                    }
                }
                currentDeck.sort(customDeckSort);
                renderDeckGrid(currentDeckGrid, currentDeck);
                draggedCardId = null;
            });
        });

        if (saveDeckButton) {
            saveDeckButton.addEventListener('click', () => {
                const validationResult = validateDeck(currentDeck);
                if (validationResult.isValid) {
                    saveDeck();
                } else {
                    alert(validationResult.message);
                }
            });
        }

        if (backButton) {
            backButton.addEventListener('click', () => {
                window.location.href = 'deck_selection.html';
            });
        }

        renderAllCardsGrid(allCardsGrid, allCardsData);
        loadDeck();
        cardInfoPanel.innerHTML = `<h2>カード情報</h2><p>カードにカーソルを合わせると詳細が表示されます。</p>`;
    </script>
</body>
</html>